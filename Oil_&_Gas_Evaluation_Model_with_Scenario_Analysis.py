{
  "cells": [
    {
      "cell_type": "code",
      "source": [
        "import datetime\n",
        "from dataclasses import dataclass, field\n",
        "from typing import List, Optional, Dict, Any\n",
        "from pathlib import Path\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import math\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.optimize import curve_fit\n",
        "\n",
        "# The Streamlit import is wrapped in a try/except so that the module can be\n",
        "# imported for unit testing even if Streamlit is not installed.  If you run\n",
        "# this file as an app (via `streamlit run`), Streamlit must be installed.\n",
        "try:\n",
        "    import streamlit as st  # type: ignore\n",
        "except ImportError:\n",
        "    st = None\n",
        "\n",
        "\n",
        "@dataclass\n",
        "class Well:\n",
        "    \"\"\"Container for well properties used in the DCF model.\"\"\"\n",
        "    name: str\n",
        "    well_type: str  # 'PDP', 'PUD', or 'Future'\n",
        "    first_prod_date: datetime.date\n",
        "    # Decline parameters\n",
        "    qi_oil: float  # initial oil rate in bbl/d\n",
        "    qi_gas: float  # initial gas rate in Mcf/d\n",
        "    qi_ngl: float  # initial NGL rate in bbl/d\n",
        "    b_factor: float\n",
        "    initial_decline: float  # annual fraction (e.g., 0.7 for 70 %)\n",
        "    terminal_decline: float  # annual fraction (e.g., 0.05 for 5 %)\n",
        "    royalty_decimal: float  # fraction of royalty interest owned\n",
        "    nri: float  # net revenue interest (1 - burdens)\n",
        "    # Derived fields for internal use\n",
        "    start_month_index: int = field(init=False, default=0)\n",
        "\n",
        "    def set_start_index(self, model_start: datetime.date) -> None:\n",
        "        \"\"\"Calculate the zero‑based month index of the well’s first production.\n",
        "\n",
        "        This method is called after all wells are defined so that the model can\n",
        "        align production with the global time axis.\n",
        "        \"\"\"\n",
        "        delta = (self.first_prod_date.year - model_start.year) * 12 + (\n",
        "            self.first_prod_date.month - model_start.month\n",
        "        )\n",
        "        self.start_month_index = max(0, delta)\n",
        "\n",
        "    def to_dict(self) -> Dict[str, Any]:\n",
        "        \"\"\"Serializes the well object to a dictionary for session state.\"\"\"\n",
        "        return {\n",
        "            'name': self.name,\n",
        "            'well_type': self.well_type,\n",
        "            'first_prod_date': self.first_prod_date.isoformat(),\n",
        "            'qi_oil': self.qi_oil,\n",
        "            'qi_gas': self.qi_gas,\n",
        "            'qi_ngl': self.qi_ngl,\n",
        "            'b_factor': self.b_factor,\n",
        "            'initial_decline': self.initial_decline,\n",
        "            'terminal_decline': self.terminal_decline,\n",
        "            'royalty_decimal': self.royalty_decimal,\n",
        "            'nri': self.nri,\n",
        "        }\n",
        "\n",
        "    @classmethod\n",
        "    def from_dict(cls, data: Dict[str, Any]) -> \"Well\":\n",
        "        \"\"\"Creates a Well object from a dictionary.\"\"\"\n",
        "        return cls(\n",
        "            name=data['name'],\n",
        "            well_type=data['well_type'],\n",
        "            first_prod_date=datetime.date.fromisoformat(data['first_prod_date']),\n",
        "            qi_oil=data['qi_oil'],\n",
        "            qi_gas=data['qi_gas'],\n",
        "            qi_ngl=data['qi_ngl'],\n",
        "            b_factor=data['b_factor'],\n",
        "            initial_decline=data['initial_decline'],\n",
        "            terminal_decline=data['terminal_decline'],\n",
        "            royalty_decimal=data['royalty_decimal'],\n",
        "            nri=data['nri'],\n",
        "        )\n",
        "\n",
        "\n",
        "def hyperbolic_decline_rate(qi: float, Di: float, b: float, Dt: float, months: int) -> np.ndarray:\n",
        "    \"\"\"Generate a monthly production forecast using a hyperbolic decline curve.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    qi : float\n",
        "        Initial production rate (units per day).\n",
        "    Di : float\n",
        "        Initial decline rate per year (fraction).  For example, 0.7 means\n",
        "        70 % decline in the first year.\n",
        "    b : float\n",
        "        Arps b‑factor.  Typical shale wells fall between 0.3 and 1.0; we use\n",
        "        0.5 as a conservative default【787064351170111†L75-L87】.\n",
        "    Dt : float\n",
        "        Terminal exponential decline rate per year (fraction).  Once the\n",
        "        hyperbolic decline rate falls below Dt, the curve transitions to\n",
        "        exponential decline.\n",
        "    months : int\n",
        "        Number of months to forecast.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    np.ndarray\n",
        "        Array of monthly average production rates (units per month).  Units of\n",
        "        the returned values are the same as `qi` multiplied by days per month.\n",
        "    \"\"\"\n",
        "    # Convert annual rates to monthly rates\n",
        "    Di_m = Di / 12.0\n",
        "    Dt_m = Dt / 12.0\n",
        "    t = np.arange(months, dtype=float)\n",
        "    # Hyperbolic decline until the instantaneous decline rate falls below Dt\n",
        "    # q(t) = qi / (1 + b * Di_m * t)**(1/b)\n",
        "    q_hyp = qi / np.power(1 + b * Di_m * t, 1 / b)\n",
        "    # Instantaneous decline rate d(t) = Di / (1 + b * Di_m * t)\n",
        "    inst_decline = Di / (1 + b * Di_m * t)\n",
        "    # Find the transition month index where inst_decline <= Dt\n",
        "    switch_idx = np.argmax(inst_decline <= Dt_m) # Corrected to compare with monthly terminal rate\n",
        "\n",
        "    # If the hyperbolic decline never falls below the terminal rate, use all\n",
        "    # hyperbolic values.  Otherwise, switch to exponential after the switch_idx.\n",
        "    if switch_idx == 0 and inst_decline[0] <= Dt_m:\n",
        "        # Start immediately on exponential decline\n",
        "        q = qi * np.power(1 - Dt_m, t)  # exponential decline from initial rate\n",
        "    elif inst_decline[-1] > Dt_m:\n",
        "        # Hyperbolic curve never meets terminal decline; use entire hyperbolic\n",
        "        q = q_hyp.copy()\n",
        "    else:\n",
        "        # Combine hyperbolic up to switch_idx, exponential afterwards\n",
        "        q = q_hyp.copy()\n",
        "        # Calculate the rate at the switch point\n",
        "        q_switch = q_hyp[switch_idx]\n",
        "        # Apply exponential decline from the switch point onwards\n",
        "        time_since_switch = np.arange(months - switch_idx)\n",
        "        q[switch_idx:] = q_switch * np.power(1 - Dt_m, time_since_switch)\n",
        "\n",
        "    # Convert daily rate to monthly volume (approximate 30.4375 days per month)\n",
        "    return q * 30.4375\n",
        "\n",
        "\n",
        "def build_price_deck(\n",
        "    start_date: datetime.date,\n",
        "    months: int,\n",
        "    oil_price: float,\n",
        "    gas_price: float,\n",
        "    ngl_price: float,\n",
        "    diff_oil: float,\n",
        "    diff_gas: float,\n",
        "    diff_ngl: float,\n",
        "    uploaded_deck: Optional[pd.DataFrame] = None,\n",
        ") -> pd.DataFrame:\n",
        "    \"\"\"Create a monthly price deck for oil, gas, and NGL.\n",
        "\n",
        "    If `uploaded_deck` is provided, it should contain columns named\n",
        "    'date', 'oil', 'gas', and 'ngl' with dates sorted ascending.  Any rows\n",
        "    beyond the forecast horizon are ignored; if the uploaded deck is shorter\n",
        "    than the horizon, the last available price is extended forward.\n",
        "\n",
        "    If no deck is uploaded, flat pricing is used based on the provided\n",
        "    `oil_price`, `gas_price`, and `ngl_price` parameters.\n",
        "\n",
        "    Price differentials are subtracted from the base prices to arrive at net\n",
        "    realized prices.\n",
        "\n",
        "    Returns a DataFrame with columns: 'date', 'oil', 'gas', 'ngl'.\n",
        "    \"\"\"\n",
        "    dates = pd.to_datetime([start_date + pd.DateOffset(months=i) for i in range(months)])\n",
        "\n",
        "    if uploaded_deck is not None and not uploaded_deck.empty:\n",
        "        # Clean and sort the uploaded deck\n",
        "        deck = uploaded_deck.copy()\n",
        "        # Ensure correct dtypes\n",
        "        for col in ['oil', 'gas', 'ngl']:\n",
        "            if col in deck.columns:\n",
        "                deck[col] = pd.to_numeric(deck[col], errors='coerce')\n",
        "        if 'date' in deck.columns:\n",
        "            deck['date'] = pd.to_datetime(deck['date'], errors='coerce')\n",
        "            deck = deck.dropna(subset=['date']).sort_values('date').reset_index(drop=True)\n",
        "\n",
        "        # Create a DataFrame for the full forecast period\n",
        "        price_df = pd.DataFrame(index=dates)\n",
        "\n",
        "        # Merge the uploaded deck\n",
        "        price_df = pd.merge_asof(price_df, deck[['date', 'oil', 'gas', 'ngl']], left_index=True, right_on='date', direction='backward')\n",
        "        price_df.index = dates # Reset index to the forecast dates\n",
        "\n",
        "        # Forward fill any missing values from the merge\n",
        "        price_df[['oil', 'gas', 'ngl']] = price_df[['oil', 'gas', 'ngl']].ffill()\n",
        "\n",
        "        # Backward fill any initial NaNs with the first available price\n",
        "        price_df[['oil', 'gas', 'ngl']] = price_df[['oil', 'gas', 'ngl']].bfill()\n",
        "\n",
        "        # If still NaN (e.g., empty deck), use flat prices\n",
        "        price_df['oil'] = price_df['oil'].fillna(oil_price)\n",
        "        price_df['gas'] = price_df['gas'].fillna(gas_price)\n",
        "        price_df['ngl'] = price_df['ngl'].fillna(ngl_price)\n",
        "\n",
        "        oil_prices = price_df['oil'].values\n",
        "        gas_prices = price_df['gas'].values\n",
        "        ngl_prices = price_df['ngl'].values\n",
        "    else:\n",
        "        oil_prices = [oil_price] * months\n",
        "        gas_prices = [gas_price] * months\n",
        "        ngl_prices = [ngl_price] * months\n",
        "\n",
        "    # Apply price differentials\n",
        "    oil_prices = np.array(oil_prices) - diff_oil\n",
        "    gas_prices = np.array(gas_prices) - diff_gas\n",
        "    ngl_prices = np.array(ngl_prices) - diff_ngl\n",
        "\n",
        "    return pd.DataFrame(\n",
        "        {\n",
        "            'date': dates,\n",
        "            'oil': oil_prices,\n",
        "            'gas': gas_prices,\n",
        "            'ngl': ngl_prices,\n",
        "        }\n",
        "    )\n",
        "\n",
        "\n",
        "def compute_cash_flows(\n",
        "    wells: List[Well],\n",
        "    price_deck: pd.DataFrame,\n",
        "    severance_tax_oil: float,\n",
        "    severance_tax_gas: float,\n",
        "    ad_valorem_tax: float,\n",
        "    post_prod_cost_pct: float,\n",
        "    discount_rate: float,\n",
        "    forecast_months: int,\n",
        ") -> pd.DataFrame:\n",
        "    \"\"\"Compute monthly cash flows and summary metrics for a list of wells.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    wells : List[Well]\n",
        "        List of wells with defined decline parameters and royalty interest info.\n",
        "    price_deck : pd.DataFrame\n",
        "        DataFrame with columns 'date', 'oil', 'gas', 'ngl' representing the\n",
        "        monthly price deck net of differentials.\n",
        "    severance_tax_oil : float\n",
        "        Oil severance tax rate (e.g., 0.046 for 4.6 %).\n",
        "    severance_tax_gas : float\n",
        "        Natural gas severance tax rate (e.g., 0.075 for 7.5 %).\n",
        "    ad_valorem_tax : float\n",
        "        Ad valorem (property) tax rate (applied to gross revenue).\n",
        "    post_prod_cost_pct : float\n",
        "        Post‑production cost as a fraction of revenue (e.g., 0.02 for 2 %).\n",
        "    discount_rate : float\n",
        "        Annual discount rate (decimal) used to compute present value.\n",
        "    forecast_months : int\n",
        "        Number of months to forecast.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    DataFrame\n",
        "        A DataFrame containing monthly cash flows for each well and totals,\n",
        "        plus additional columns for discounted cash flows and cumulative cash\n",
        "        flows.\n",
        "    \"\"\"\n",
        "    # Initialize arrays for aggregate production and revenue\n",
        "    total_oil_vol = np.zeros(forecast_months)\n",
        "    total_gas_vol = np.zeros(forecast_months)\n",
        "    total_ngl_vol = np.zeros(forecast_months)\n",
        "\n",
        "    total_net_royalty_rev = np.zeros(forecast_months)\n",
        "\n",
        "    # For PV by well type, accumulate net cash by type\n",
        "    pv_by_type = {'PDP': 0.0, 'PUD': 0.0, 'Future': 0.0}\n",
        "    undiscounted_by_type = {'PDP': 0.0, 'PUD': 0.0, 'Future': 0.0}\n",
        "\n",
        "    # Precompute monthly discount factor from annual discount rate\n",
        "    disc_m = (1 + discount_rate) ** (1 / 12.0)\n",
        "    discount_factors = 1 / np.power(disc_m, np.arange(forecast_months))\n",
        "\n",
        "    # Loop over wells\n",
        "    for well in wells:\n",
        "        # Production arrays for this well\n",
        "        oil = hyperbolic_decline_rate(\n",
        "            qi=well.qi_oil, Di=well.initial_decline, b=well.b_factor,\n",
        "            Dt=well.terminal_decline, months=forecast_months,\n",
        "        )\n",
        "        gas = hyperbolic_decline_rate(\n",
        "            qi=well.qi_gas, Di=well.initial_decline, b=well.b_factor,\n",
        "            Dt=well.terminal_decline, months=forecast_months,\n",
        "        )\n",
        "        ngl = hyperbolic_decline_rate(\n",
        "            qi=well.qi_ngl, Di=well.initial_decline, b=well.b_factor,\n",
        "            Dt=well.terminal_decline, months=forecast_months,\n",
        "        )\n",
        "        # Shift production by start month index\n",
        "        oil_shift = np.zeros(forecast_months)\n",
        "        gas_shift = np.zeros(forecast_months)\n",
        "        ngl_shift = np.zeros(forecast_months)\n",
        "        idx = well.start_month_index\n",
        "        if idx < forecast_months:\n",
        "            length = min(forecast_months - idx, forecast_months)\n",
        "            oil_shift[idx : idx + length] = oil[:length]\n",
        "            gas_shift[idx : idx + length] = gas[:length]\n",
        "            ngl_shift[idx : idx + length] = ngl[:length]\n",
        "\n",
        "        # Accumulate gross volumes\n",
        "        total_oil_vol += oil_shift\n",
        "        total_gas_vol += gas_shift\n",
        "        total_ngl_vol += ngl_shift\n",
        "\n",
        "        # Compute gross revenue for this well\n",
        "        revenue_oil = oil_shift * price_deck['oil'].values\n",
        "        revenue_gas = gas_shift * price_deck['gas'].values\n",
        "        revenue_ngl = ngl_shift * price_deck['ngl'].values\n",
        "        gross_rev = revenue_oil + revenue_gas + revenue_ngl\n",
        "\n",
        "        # Taxes\n",
        "        tax = (\n",
        "            revenue_oil * severance_tax_oil\n",
        "            + revenue_gas * severance_tax_gas\n",
        "            + revenue_ngl * severance_tax_oil  # assume NGL taxed like oil\n",
        "        )\n",
        "        ad_val = gross_rev * ad_valorem_tax\n",
        "\n",
        "        # Post‑production costs\n",
        "        post_prod = gross_rev * post_prod_cost_pct\n",
        "\n",
        "        # Net revenue after taxes and costs\n",
        "        net_rev = gross_rev - tax - ad_val - post_prod\n",
        "\n",
        "        # Net to royalty owner (royalty decimal * NRI)\n",
        "        net_royalty = net_rev * well.royalty_decimal * well.nri\n",
        "\n",
        "        # Accumulate total net royalty revenue\n",
        "        total_net_royalty_rev += net_royalty\n",
        "\n",
        "        # Accumulate for PV by type\n",
        "        undiscounted_by_type[well.well_type] += net_royalty.sum()\n",
        "        pv_by_type[well.well_type] += (net_royalty * discount_factors).sum()\n",
        "\n",
        "    # Aggregate cash flow across all wells (per month)\n",
        "    gross_rev_total = (\n",
        "        total_oil_vol * price_deck['oil'].values\n",
        "        + total_gas_vol * price_deck['gas'].values\n",
        "        + total_ngl_vol * price_deck['ngl'].values\n",
        "    )\n",
        "    tax_total = (\n",
        "        total_oil_vol * price_deck['oil'].values * severance_tax_oil\n",
        "        + total_gas_vol * price_deck['gas'].values * severance_tax_gas\n",
        "        + total_ngl_vol * price_deck['ngl'].values * severance_tax_oil # NGL taxed like oil\n",
        "    )\n",
        "    ad_val_total = gross_rev_total * ad_valorem_tax\n",
        "    post_prod_total = gross_rev_total * post_prod_cost_pct\n",
        "    net_rev_total = gross_rev_total - tax_total - ad_val_total - post_prod_total\n",
        "\n",
        "    # Discounted cash flow\n",
        "    discounted_cf = total_net_royalty_rev * discount_factors\n",
        "    # Cumulative cash flow\n",
        "    cumulative_cf = np.cumsum(total_net_royalty_rev)\n",
        "    cumulative_discounted = np.cumsum(discounted_cf)\n",
        "\n",
        "    # Build DataFrame of results\n",
        "    result = pd.DataFrame(\n",
        "        {\n",
        "            'date': price_deck['date'],\n",
        "            'gross_revenue': gross_rev_total,\n",
        "            'taxes': tax_total + ad_val_total,\n",
        "            'post_prod_costs': post_prod_total,\n",
        "            'net_revenue': net_rev_total,\n",
        "            'net_royalty': total_net_royalty_rev,\n",
        "            'discount_factor': discount_factors,\n",
        "            'discounted_cf': discounted_cf,\n",
        "            'cumulative_cf': cumulative_cf,\n",
        "            'cumulative_discounted': cumulative_discounted,\n",
        "        }\n",
        "    )\n",
        "    # Append summary metrics as attributes\n",
        "    result.attrs['undiscounted_total'] = total_net_royalty_rev.sum()\n",
        "    result.attrs['discounted_total'] = discounted_cf.sum()\n",
        "    result.attrs['pv_by_type'] = pv_by_type\n",
        "    result.attrs['undiscounted_by_type'] = undiscounted_by_type\n",
        "    return result\n",
        "\n",
        "\n",
        "# ---------------------------------------------------------------------------\n",
        "# Investment metrics helper\n",
        "#\n",
        "# This helper takes the result DataFrame produced by ``compute_cash_flows`` and\n",
        "# a user‑defined acquisition cost to derive additional investment metrics.\n",
        "# It calculates the internal rate of return (IRR), the payback period (based\n",
        "# on undiscounted and discounted cash flows), the profitability index (PI)\n",
        "# and the multiple on invested capital (MOIC).  It also constructs an\n",
        "# augmented cash flow table that includes the initial capital outlay at a\n",
        "# specified closing month.\n",
        "def compute_investment_metrics(\n",
        "    result_df: pd.DataFrame,\n",
        "    acquisition_cost: float,\n",
        "    discount_rate: float,\n",
        "    model_start: datetime.date,\n",
        "    closing_date: Optional[datetime.date] = None,\n",
        ") -> dict:\n",
        "    \"\"\"\n",
        "    Compute investment performance metrics given a cash flow forecast and an\n",
        "    acquisition cost.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    result_df : pd.DataFrame\n",
        "        DataFrame returned by ``compute_cash_flows`` containing monthly net\n",
        "        royalty cash flows and discount factors.\n",
        "    acquisition_cost : float\n",
        "        Positive dollar amount representing the upfront purchase price or\n",
        "        capital outlay.  This cost will be treated as a negative cash flow.\n",
        "    discount_rate : float\n",
        "        Annual discount rate (decimal) used for discounted payback period and\n",
        "        NPV calculations.\n",
        "    model_start : datetime.date\n",
        "        The start date of the forecast.  Used to align the closing month.\n",
        "    closing_date : Optional[datetime.date], default None\n",
        "        Date when the acquisition cost is incurred.  If None, the cost is\n",
        "        applied at the first month of the forecast.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    dict\n",
        "        A dictionary containing the following keys:\n",
        "        - ``cash_flow_table`` (pd.DataFrame): augmented table with columns\n",
        "          ['date', 'cash_inflow', 'acquisition', 'net_cash',\n",
        "           'discount_factor', 'discounted_net_cash', 'cumulative_net_cash',\n",
        "           'cumulative_discounted'].\n",
        "        - ``irr_annual`` (float or None): annualized internal rate of return.\n",
        "        - ``payback_months`` (int or None): payback period in months based on\n",
        "          undiscounted cash flows (including the initial cost).\n",
        "        - ``discounted_payback_months`` (int or None): payback period in\n",
        "          months based on discounted cash flows.\n",
        "        - ``npv`` (float): net present value of the investment at the\n",
        "          specified discount rate.\n",
        "        - ``profitability_index`` (float or None): profitability index\n",
        "          (PV of returns divided by acquisition cost).\n",
        "        - ``moic`` (float or None): multiple on invested capital (total\n",
        "          undiscounted returns divided by acquisition cost).\n",
        "    \"\"\"\n",
        "    # Copy relevant arrays\n",
        "    cash_inflow = result_df['net_royalty'].values.astype(float)\n",
        "    discount_factors = result_df['discount_factor'].values.astype(float)\n",
        "    dates = result_df['date'].values\n",
        "    n_periods = len(cash_inflow)\n",
        "    # Determine the month index when the acquisition occurs\n",
        "    if closing_date is None:\n",
        "        closing_month_index = 0\n",
        "    else:\n",
        "        # Compute difference in months between closing_date and model_start\n",
        "        delta_months = (closing_date.year - model_start.year) * 12 + (closing_date.month - model_start.month)\n",
        "        closing_month_index = max(0, int(delta_months))\n",
        "        # Cap at forecast horizon\n",
        "        if closing_month_index >= n_periods:\n",
        "            closing_month_index = n_periods - 1\n",
        "    # Build arrays for acquisition and net cash\n",
        "    acquisition_array = np.zeros(n_periods)\n",
        "    if acquisition_cost > 0:\n",
        "        acquisition_array[closing_month_index] = -acquisition_cost\n",
        "    # Net cash including acquisition cost\n",
        "    net_cash = cash_inflow + acquisition_array\n",
        "    # Discounted net cash\n",
        "    discounted_net_cash = net_cash * discount_factors\n",
        "    # Cumulative sums\n",
        "    cumulative_net_cash = np.cumsum(net_cash)\n",
        "    cumulative_discounted = np.cumsum(discounted_net_cash)\n",
        "    # Compute IRR on monthly basis; annualize if possible\n",
        "    irr_monthly = None\n",
        "    try:\n",
        "        # Prefer numpy_financial if available for accurate IRR calculation\n",
        "        try:\n",
        "            import numpy_financial as npf  # type: ignore\n",
        "            irr_val = npf.irr(net_cash)\n",
        "        except Exception:\n",
        "            # Fall back to numpy's IRR if available\n",
        "            irr_val = np.irr(net_cash)  # type: ignore[attr-defined]\n",
        "        if irr_val is not None and not np.isnan(irr_val):\n",
        "            irr_monthly = irr_val\n",
        "    except Exception:\n",
        "        irr_monthly = None\n",
        "    if irr_monthly is not None and np.isfinite(irr_monthly):\n",
        "        irr_annual = (1 + irr_monthly) ** 12 - 1\n",
        "    else:\n",
        "        irr_annual = None\n",
        "    # Payback periods\n",
        "    payback_months = None\n",
        "    idx = np.where(cumulative_net_cash > 0)[0]\n",
        "    if len(idx) > 0:\n",
        "        payback_months = int(idx[0])\n",
        "    discounted_payback_months = None\n",
        "    idx_d = np.where(cumulative_discounted > 0)[0]\n",
        "    if len(idx_d) > 0:\n",
        "        discounted_payback_months = int(idx_d[0])\n",
        "    # NPV (PV of returns minus cost)\n",
        "    npv = discounted_net_cash.sum()\n",
        "\n",
        "    profitability_index = None\n",
        "    if acquisition_cost > 0:\n",
        "        pv_returns = result_df['discounted_cf'].sum()\n",
        "        profitability_index = pv_returns / acquisition_cost\n",
        "\n",
        "    moic = None\n",
        "    if acquisition_cost > 0:\n",
        "        total_return = cash_inflow.sum()\n",
        "        moic = total_return / acquisition_cost\n",
        "    # Build augmented table\n",
        "    cf_table = pd.DataFrame({\n",
        "        'date': dates,\n",
        "        'cash_inflow': cash_inflow,\n",
        "        'acquisition': acquisition_array,\n",
        "        'net_cash': net_cash,\n",
        "        'discount_factor': discount_factors,\n",
        "        'discounted_net_cash': discounted_net_cash,\n",
        "        'cumulative_net_cash': cumulative_net_cash,\n",
        "        'cumulative_discounted': cumulative_discounted,\n",
        "    })\n",
        "    return {\n",
        "        'cash_flow_table': cf_table,\n",
        "        'irr_annual': irr_annual,\n",
        "        'payback_months': payback_months,\n",
        "        'discounted_payback_months': discounted_payback_months,\n",
        "        'npv': npv,\n",
        "        'profitability_index': profitability_index,\n",
        "        'moic': moic,\n",
        "    }\n",
        "\n",
        "\n",
        "def run_monte_carlo(\n",
        "    wells: List[Well],\n",
        "    price_deck: pd.DataFrame,\n",
        "    severance_tax_oil: float,\n",
        "    severance_tax_gas: float,\n",
        "    ad_valorem_tax: float,\n",
        "    post_prod_cost_pct: float,\n",
        "    discount_rate: float,\n",
        "    forecast_months: int,\n",
        "    model_start: datetime.date,\n",
        "    iterations: int = 100,\n",
        "    price_sigma: float = 0.10,\n",
        "    vol_sigma: float = 0.10,\n",
        ") -> np.ndarray:\n",
        "    \"\"\"\n",
        "    Perform a simple Monte Carlo simulation on price and production assumptions.\n",
        "\n",
        "    Each iteration perturbs the entire price deck by a normally distributed\n",
        "    multiplier (mean 1, standard deviation `price_sigma`) and perturbs the\n",
        "    initial production rates of every well by a multiplier (mean 1,\n",
        "    standard deviation `vol_sigma`).  The decline parameters and start dates\n",
        "    remain unchanged.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    np.ndarray\n",
        "        Array of discounted net present values (one per iteration).\n",
        "    \"\"\"\n",
        "    results = []\n",
        "    # Pre-generate random multipliers for efficiency\n",
        "    price_factors = np.random.normal(loc=1.0, scale=price_sigma, size=iterations)\n",
        "    vol_factors = np.random.normal(loc=1.0, scale=vol_sigma, size=iterations)\n",
        "    for i in range(iterations):\n",
        "        # Adjust price deck\n",
        "        deck = price_deck.copy()\n",
        "        deck['oil'] *= price_factors[i]\n",
        "        deck['gas'] *= price_factors[i]\n",
        "        deck['ngl'] *= price_factors[i]\n",
        "        # Adjust wells\n",
        "        sim_wells: List[Well] = []\n",
        "        for well in wells:\n",
        "            new_well = Well(\n",
        "                name=well.name,\n",
        "                well_type=well.well_type,\n",
        "                first_prod_date=well.first_prod_date,\n",
        "                qi_oil=well.qi_oil * vol_factors[i],\n",
        "                qi_gas=well.qi_gas * vol_factors[i],\n",
        "                qi_ngl=well.qi_ngl * vol_factors[i],\n",
        "                b_factor=well.b_factor,\n",
        "                initial_decline=well.initial_decline,\n",
        "                terminal_decline=well.terminal_decline,\n",
        "                royalty_decimal=well.royalty_decimal,\n",
        "                nri=well.nri,\n",
        "            )\n",
        "            new_well.set_start_index(model_start)\n",
        "            sim_wells.append(new_well)\n",
        "        sim_result = compute_cash_flows(\n",
        "            wells=sim_wells,\n",
        "            price_deck=deck,\n",
        "            severance_tax_oil=severance_tax_oil,\n",
        "            severance_tax_gas=severance_tax_gas,\n",
        "            ad_valorem_tax=ad_valorem_tax,\n",
        "            post_prod_cost_pct=post_prod_cost_pct,\n",
        "            discount_rate=discount_rate,\n",
        "            forecast_months=forecast_months,\n",
        "        )\n",
        "        results.append(sim_result.attrs['discounted_total'])\n",
        "    return np.array(results)\n",
        "\n",
        "\n",
        "# -----------------------------------------------------------------------------\n",
        "# Decline Curve Analysis utilities\n",
        "# -----------------------------------------------------------------------------\n",
        "def exp_decline(t: np.ndarray, qi: float, Di: float) -> np.ndarray:\n",
        "    \"\"\"Exponential decline model: q = qi * exp(-Di * t).\"\"\"\n",
        "    return qi * np.exp(-Di * t)\n",
        "\n",
        "\n",
        "def hyp_decline(t: np.ndarray, qi: float, Di: float, b: float) -> np.ndarray:\n",
        "    \"\"\"Hyperbolic decline model: q = qi / (1 + b * Di * t)**(1/b).\"\"\"\n",
        "    return qi / np.power(1 + b * Di * t, 1.0 / b)\n",
        "\n",
        "\n",
        "def harm_decline(t: np.ndarray, qi: float, Di: float) -> np.ndarray:\n",
        "    \"\"\"Harmonic decline model: q = qi / (1 + Di * t).\"\"\"\n",
        "    return qi / (1 + Di * t)\n",
        "\n",
        "\n",
        "def fit_decline_model(\n",
        "    t: np.ndarray,\n",
        "    q: np.ndarray,\n",
        "    model: str,\n",
        "    b_override: Optional[float] = None,\n",
        "    min_terminal_decline: float = 0.05,\n",
        ") -> dict:\n",
        "    \"\"\"\n",
        "    Fit a decline curve model to production data using non-linear regression.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    t : np.ndarray\n",
        "        Time in months since first production.\n",
        "    q : np.ndarray\n",
        "        Production rate per month (units per month or per day; relative scale is preserved).\n",
        "    model : str\n",
        "        Decline model type: 'Exponential', 'Hyperbolic', or 'Harmonic'.\n",
        "    b_override : Optional[float]\n",
        "        If provided and the model is hyperbolic, force the b‑factor to this value instead of fitting.\n",
        "    min_terminal_decline : float\n",
        "        Minimum terminal decline rate per year used to compute Dₜ in exponential tail.  Not used directly in fitting but returned for reference.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    dict\n",
        "        Dictionary containing fitted parameters (qi, Di, b), model type, R², RMSE, and predicted values.\n",
        "    \"\"\"\n",
        "    # Provide reasonable initial guesses\n",
        "    qi0 = max(q[0], 1e-6)\n",
        "    # Estimate initial decline from the first two points using log difference\n",
        "    if len(q) > 1 and q[1] > 0 and q[0] > 0:\n",
        "        Di0 = max((np.log(q[0]) - np.log(q[1])) / (t[1] - t[0]), 1e-6)\n",
        "    else:\n",
        "        Di0 = 0.1\n",
        "    try:\n",
        "        if model == 'Exponential':\n",
        "            popt, _ = curve_fit(exp_decline, t, q, p0=[qi0, Di0], bounds=(0, [np.inf, 1]))\n",
        "            qi_fit, Di_fit = popt\n",
        "            b_fit = 0.0\n",
        "            q_pred = exp_decline(t, qi_fit, Di_fit)\n",
        "        elif model == 'Harmonic':\n",
        "            popt, _ = curve_fit(harm_decline, t, q, p0=[qi0, Di0], bounds=(0, [np.inf, 1]))\n",
        "            qi_fit, Di_fit = popt\n",
        "            b_fit = 1.0\n",
        "            q_pred = harm_decline(t, qi_fit, Di_fit)\n",
        "        elif model == 'Hyperbolic':\n",
        "            if b_override is not None:\n",
        "                # Fit only qi and Di with fixed b\n",
        "                def hyp_fixed(t, qi, Di):\n",
        "                    return hyp_decline(t, qi, Di, b_override)\n",
        "                popt, _ = curve_fit(hyp_fixed, t, q, p0=[qi0, Di0], bounds=(0, [np.inf, 1]))\n",
        "                qi_fit, Di_fit = popt\n",
        "                b_fit = b_override\n",
        "                q_pred = hyp_decline(t, qi_fit, Di_fit, b_fit)\n",
        "            else:\n",
        "                popt, _ = curve_fit(hyp_decline, t, q, p0=[qi0, Di0, 0.5], bounds=(0, [np.inf, 1, 2]))\n",
        "                qi_fit, Di_fit, b_fit = popt\n",
        "                q_pred = hyp_decline(t, qi_fit, Di_fit, b_fit)\n",
        "        else:\n",
        "            raise ValueError('Unknown decline model')\n",
        "    except Exception as e:\n",
        "        return {\n",
        "            'model': model,\n",
        "            'qi': np.nan,\n",
        "            'Di': np.nan,\n",
        "            'b': np.nan,\n",
        "            'error': str(e),\n",
        "        }\n",
        "    # Goodness-of-fit metrics\n",
        "    ss_res = np.sum((q - q_pred) ** 2)\n",
        "    ss_tot = np.sum((q - np.mean(q)) ** 2)\n",
        "    r_squared = 1 - ss_res / ss_tot if ss_tot > 0 else np.nan\n",
        "    rmse = np.sqrt(ss_res / len(q))\n",
        "    return {\n",
        "        'model': model,\n",
        "        'qi': qi_fit,\n",
        "        'Di': Di_fit,\n",
        "        'b': b_fit,\n",
        "        'R2': r_squared,\n",
        "        'RMSE': rmse,\n",
        "        'q_pred': q_pred,\n",
        "        'min_terminal_decline': min_terminal_decline,\n",
        "    }\n",
        "\n",
        "\n",
        "def get_default_scenario():\n",
        "    \"\"\"Returns a dictionary with the default input values for a new scenario.\"\"\"\n",
        "    return {\n",
        "        \"model_start\": datetime.date(datetime.date.today().year, datetime.date.today().month, 1),\n",
        "        \"forecast_months\": 360,\n",
        "        \"discount_rate\": 0.10,\n",
        "        \"price_option\": \"Flat pricing\",\n",
        "        \"oil_price\": 70.0,\n",
        "        \"gas_price\": 3.50,\n",
        "        \"ngl_price\": 25.0,\n",
        "        \"diff_oil\": 3.0,\n",
        "        \"diff_gas\": 0.50,\n",
        "        \"diff_ngl\": 2.0,\n",
        "        \"severance_tax_oil\": 0.046,\n",
        "        \"severance_tax_gas\": 0.075,\n",
        "        \"ad_valorem_tax\": 0.01,\n",
        "        \"post_prod_pct\": 0.0,\n",
        "        \"well_count\": 1,\n",
        "        \"wells\": [Well(\n",
        "            name='Well 1', well_type='PDP', first_prod_date=datetime.date.today(),\n",
        "            qi_oil=300.0, qi_gas=800.0, qi_ngl=20.0, b_factor=0.5,\n",
        "            initial_decline=0.70, terminal_decline=0.05,\n",
        "            royalty_decimal=0.1875, nri=0.80\n",
        "        ).to_dict()],\n",
        "        \"acquisition_cost\": 0.0,\n",
        "        \"closing_date\": datetime.date(datetime.date.today().year, datetime.date.today().month, 1),\n",
        "    }\n",
        "\n",
        "def render_app() -> None:\n",
        "    \"\"\"Main function to render the Streamlit application.\"\"\"\n",
        "    if st is None:\n",
        "        raise RuntimeError(\n",
        "            \"Streamlit is not installed. Please install streamlit and run\\n\"\n",
        "            \"`streamlit run dcf_model_web_app.py` from the command line.\"\n",
        "        )\n",
        "\n",
        "    st.set_page_config(layout=\"wide\")\n",
        "\n",
        "    # --- Initialize Session State for Scenarios ---\n",
        "    if 'scenarios' not in st.session_state:\n",
        "        st.session_state.scenarios = {\"Default Case\": get_default_scenario()}\n",
        "    if 'active_scenario' not in st.session_state:\n",
        "        st.session_state.active_scenario = \"Default Case\"\n",
        "    if 'uploaded_deck' not in st.session_state:\n",
        "        st.session_state.uploaded_deck = None\n",
        "\n",
        "\n",
        "    # --- Sidebar ---\n",
        "    st.sidebar.header('Scenario Management')\n",
        "\n",
        "    # Scenario selection\n",
        "    scenario_names = list(st.session_state.scenarios.keys())\n",
        "    st.session_state.active_scenario = st.sidebar.selectbox(\n",
        "        \"Active Scenario\",\n",
        "        scenario_names,\n",
        "        index=scenario_names.index(st.session_state.active_scenario),\n",
        "        key=\"scenario_selector\"\n",
        "    )\n",
        "\n",
        "    # Load active scenario data\n",
        "    active_scenario_data = st.session_state.scenarios[st.session_state.active_scenario]\n",
        "\n",
        "    # Scenario creation/deletion\n",
        "    with st.sidebar.expander(\"Create / Delete Scenario\"):\n",
        "        new_scenario_name = st.text_input(\"New Scenario Name\")\n",
        "        if st.button(\"Save as New Scenario\"):\n",
        "            if new_scenario_name and new_scenario_name not in st.session_state.scenarios:\n",
        "                st.session_state.scenarios[new_scenario_name] = active_scenario_data.copy()\n",
        "                st.session_state.active_scenario = new_scenario_name\n",
        "                st.rerun()\n",
        "            else:\n",
        "                st.warning(\"Please enter a unique name for the new scenario.\")\n",
        "\n",
        "        if st.button(\"Delete Current Scenario\", type=\"secondary\"):\n",
        "            if st.session_state.active_scenario != \"Default Case\":\n",
        "                del st.session_state.scenarios[st.session_state.active_scenario]\n",
        "                st.session_state.active_scenario = \"Default Case\"\n",
        "                st.rerun()\n",
        "            else:\n",
        "                st.warning(\"Cannot delete the Default Case.\")\n",
        "\n",
        "\n",
        "    st.sidebar.header('Global Assumptions')\n",
        "\n",
        "    # Update active scenario data from UI widgets\n",
        "    active_scenario_data[\"model_start\"] = st.sidebar.date_input(\n",
        "        'Model start date',\n",
        "        value=active_scenario_data[\"model_start\"],\n",
        "        help='All production and price forecasting begins on this date.'\n",
        "    )\n",
        "    active_scenario_data[\"forecast_months\"] = st.sidebar.number_input(\n",
        "        'Forecast horizon (months)',\n",
        "        min_value=12, max_value=480, value=active_scenario_data[\"forecast_months\"], step=12,\n",
        "        help='Number of months to forecast (e.g., 360 for 30 years).'\n",
        "    )\n",
        "    active_scenario_data[\"discount_rate\"] = st.sidebar.number_input(\n",
        "        'Discount rate (annual %)',\n",
        "        min_value=0.0, max_value=100.0, value=active_scenario_data[\"discount_rate\"]*100, step=0.5,\n",
        "        help='Enter a percentage (e.g., 10 for 10% annual rate).'\n",
        "    ) / 100.0\n",
        "\n",
        "    st.sidebar.markdown('---')\n",
        "    st.sidebar.subheader('Pricing')\n",
        "    active_scenario_data[\"price_option\"] = st.sidebar.selectbox(\n",
        "        'Price deck option', ['Flat pricing', 'Upload market strip'],\n",
        "        index=['Flat pricing', 'Upload market strip'].index(active_scenario_data[\"price_option\"]),\n",
        "        help='Choose a flat price deck or upload your own price forecasts.'\n",
        "    )\n",
        "    active_scenario_data[\"oil_price\"] = st.sidebar.number_input('Oil price ($/bbl)', value=active_scenario_data[\"oil_price\"], min_value=0.0)\n",
        "    active_scenario_data[\"gas_price\"] = st.sidebar.number_input('Gas price ($/MMBtu)', value=active_scenario_data[\"gas_price\"], min_value=0.0)\n",
        "    active_scenario_data[\"ngl_price\"] = st.sidebar.number_input('NGL price ($/bbl)', value=active_scenario_data[\"ngl_price\"], min_value=0.0)\n",
        "\n",
        "    active_scenario_data[\"diff_oil\"] = st.sidebar.number_input('Oil price differential ($/bbl)', value=active_scenario_data[\"diff_oil\"])\n",
        "    active_scenario_data[\"diff_gas\"] = st.sidebar.number_input('Gas price differential ($/MMBtu)', value=active_scenario_data[\"diff_gas\"])\n",
        "    active_scenario_data[\"diff_ngl\"] = st.sidebar.number_input('NGL price differential ($/bbl)', value=active_scenario_data[\"diff_ngl\"])\n",
        "\n",
        "    st.sidebar.subheader('Taxes & Costs')\n",
        "    active_scenario_data[\"severance_tax_oil\"] = st.sidebar.number_input('Oil severance tax (%)', value=active_scenario_data[\"severance_tax_oil\"]*100, min_value=0.0, max_value=100.0) / 100.0\n",
        "    active_scenario_data[\"severance_tax_gas\"] = st.sidebar.number_input('Gas severance tax (%)', value=active_scenario_data[\"severance_tax_gas\"]*100, min_value=0.0, max_value=100.0) / 100.0\n",
        "    active_scenario_data[\"ad_valorem_tax\"] = st.sidebar.number_input('Ad valorem tax (%)', value=active_scenario_data[\"ad_valorem_tax\"]*100, min_value=0.0, max_value=100.0) / 100.0\n",
        "    active_scenario_data[\"post_prod_pct\"] = st.sidebar.number_input('Post‑production cost (%)', value=active_scenario_data[\"post_prod_pct\"]*100, min_value=0.0, max_value=50.0) / 100.0\n",
        "\n",
        "    st.sidebar.markdown('---')\n",
        "    if active_scenario_data[\"price_option\"] == 'Upload market strip':\n",
        "        uploaded_file = st.sidebar.file_uploader(\n",
        "            'Upload CSV with columns: date, oil, gas, ngl', type=['csv'],\n",
        "            help='The date column should be in YYYY‑MM‑DD format.'\n",
        "        )\n",
        "        if uploaded_file is not None:\n",
        "            st.session_state.uploaded_deck = pd.read_csv(uploaded_file)\n",
        "    else:\n",
        "        st.session_state.uploaded_deck = None\n",
        "\n",
        "    # --- Main Page Layout ---\n",
        "    st.title('Oil & Gas Royalty Toolkit')\n",
        "    st.info(f\"**Current Scenario: {st.session_state.active_scenario}**\")\n",
        "\n",
        "    tab_dcf, tab_dca, tab_help = st.tabs(['DCF Model', 'Decline Curve Analysis', 'Help & Tutorial'])\n",
        "\n",
        "    with tab_dcf:\n",
        "        st.header('DCF Model Inputs')\n",
        "\n",
        "        # --- Well Inputs ---\n",
        "        well_count = st.number_input(\n",
        "            'Number of wells to model', min_value=1, max_value=50,\n",
        "            value=len(active_scenario_data[\"wells\"]), step=1, key=f\"well_count_{st.session_state.active_scenario}\"\n",
        "        )\n",
        "\n",
        "        # Adjust the number of wells in the scenario data if needed\n",
        "        current_wells = [Well.from_dict(w) for w in active_scenario_data[\"wells\"]]\n",
        "        if well_count > len(current_wells):\n",
        "            for i in range(len(current_wells), well_count):\n",
        "                new_well_date = active_scenario_data[\"model_start\"] + datetime.timedelta(days=30 * i)\n",
        "                current_wells.append(Well(\n",
        "                    name=f'Well {i+1}', well_type='PDP', first_prod_date=new_well_date,\n",
        "                    qi_oil=300.0, qi_gas=800.0, qi_ngl=20.0, b_factor=0.5,\n",
        "                    initial_decline=0.70, terminal_decline=0.05,\n",
        "                    royalty_decimal=0.1875, nri=0.80\n",
        "                ))\n",
        "        elif well_count < len(current_wells):\n",
        "            current_wells = current_wells[:well_count]\n",
        "\n",
        "        active_scenario_data[\"wells\"] = [w.to_dict() for w in current_wells]\n",
        "\n",
        "        wells_from_ui: List[Well] = []\n",
        "        for i in range(well_count):\n",
        "            well_data = active_scenario_data[\"wells\"][i]\n",
        "            with st.expander(f'Well {i+1}: {well_data[\"name\"]}'):\n",
        "                # Create a unique key for each widget based on scenario and well index\n",
        "                s_key = f\"{st.session_state.active_scenario}_{i}\"\n",
        "\n",
        "                well_data['name'] = st.text_input('Well name/ID', value=well_data['name'], key=f'name_{s_key}')\n",
        "                well_data['well_type'] = st.selectbox('Well type', options=['PDP', 'PUD', 'Future'], index=['PDP', 'PUD', 'Future'].index(well_data['well_type']), key=f'type_{s_key}')\n",
        "                well_data['first_prod_date'] = st.date_input('First production date', value=datetime.date.fromisoformat(well_data['first_prod_date']), key=f'fpd_{s_key}').isoformat()\n",
        "\n",
        "                c1, c2, c3 = st.columns(3)\n",
        "                well_data['qi_oil'] = c1.number_input('Initial oil rate (bbl/d)', value=well_data['qi_oil'], min_value=0.0, key=f'qi_oil_{s_key}')\n",
        "                well_data['qi_gas'] = c2.number_input('Initial gas rate (Mcf/d)', value=well_data['qi_gas'], min_value=0.0, key=f'qi_gas_{s_key}')\n",
        "                well_data['qi_ngl'] = c3.number_input('Initial NGL rate (bbl/d)', value=well_data['qi_ngl'], min_value=0.0, key=f'qi_ngl_{s_key}')\n",
        "\n",
        "                c1, c2, c3 = st.columns(3)\n",
        "                well_data['b_factor'] = c1.number_input('Arps b‑factor', value=well_data['b_factor'], min_value=0.0, max_value=2.0, step=0.1, key=f'b_{s_key}')\n",
        "                well_data['initial_decline'] = c2.number_input('Initial decline rate (%/yr)', value=well_data['initial_decline']*100, min_value=0.0, max_value=100.0, key=f'di_{s_key}') / 100.0\n",
        "                well_data['terminal_decline'] = c3.number_input('Terminal decline rate (%/yr)', value=well_data['terminal_decline']*100, min_value=0.0, max_value=30.0, key=f'dt_{s_key}') / 100.0\n",
        "\n",
        "                c1, c2 = st.columns(2)\n",
        "                well_data['royalty_decimal'] = c1.number_input('Royalty decimal (fraction)', value=well_data['royalty_decimal'], min_value=0.0, max_value=1.0, step=0.001, format=\"%.4f\", key=f'roy_{s_key}')\n",
        "                well_data['nri'] = c2.number_input('Net revenue interest (NRI)', value=well_data['nri'], min_value=0.0, max_value=1.0, step=0.01, key=f'nri_{s_key}')\n",
        "\n",
        "                wells_from_ui.append(Well.from_dict(well_data))\n",
        "\n",
        "        # --- Acquisition Inputs ---\n",
        "        st.subheader('Acquisition / Investment')\n",
        "        active_scenario_data[\"acquisition_cost\"] = st.number_input(\n",
        "            'Acquisition price (USD)', value=active_scenario_data[\"acquisition_cost\"], min_value=0.0, step=1000.0,\n",
        "            help='Enter the total purchase price for the royalty interest.'\n",
        "        )\n",
        "        if active_scenario_data[\"acquisition_cost\"] > 0:\n",
        "            active_scenario_data[\"closing_date\"] = st.date_input(\n",
        "                'Acquisition closing date', value=active_scenario_data[\"closing_date\"],\n",
        "                min_value=active_scenario_data[\"model_start\"], help='Date when the acquisition cost is incurred.'\n",
        "            )\n",
        "\n",
        "        # --- Run Forecast Buttons ---\n",
        "        st.markdown(\"---\")\n",
        "        col1, col2 = st.columns(2)\n",
        "\n",
        "        run_single = col1.button(f'Run: {st.session_state.active_scenario}', type=\"primary\")\n",
        "        run_all = col2.button('Run All Scenarios & Compare')\n",
        "\n",
        "        if run_single or run_all:\n",
        "            scenarios_to_run = st.session_state.scenarios if run_all else {st.session_state.active_scenario: active_scenario_data}\n",
        "            all_results = []\n",
        "\n",
        "            with st.spinner(\"Running forecasts...\"):\n",
        "                for name, scenario in scenarios_to_run.items():\n",
        "                    # Build wells and price deck for the current scenario\n",
        "                    wells = [Well.from_dict(w) for w in scenario['wells']]\n",
        "                    for well in wells:\n",
        "                        well.set_start_index(scenario['model_start'])\n",
        "\n",
        "                    price_deck = build_price_deck(\n",
        "                        start_date=scenario['model_start'], months=scenario['forecast_months'],\n",
        "                        oil_price=scenario['oil_price'], gas_price=scenario['gas_price'], ngl_price=scenario['ngl_price'],\n",
        "                        diff_oil=scenario['diff_oil'], diff_gas=scenario['diff_gas'], diff_ngl=scenario['diff_ngl'],\n",
        "                        uploaded_deck=st.session_state.uploaded_deck if scenario['price_option'] == 'Upload market strip' else None\n",
        "                    )\n",
        "\n",
        "                    # Compute cash flows\n",
        "                    result_df = compute_cash_flows(\n",
        "                        wells=wells, price_deck=price_deck,\n",
        "                        severance_tax_oil=scenario['severance_tax_oil'], severance_tax_gas=scenario['severance_tax_gas'],\n",
        "                        ad_valorem_tax=scenario['ad_valorem_tax'], post_prod_cost_pct=scenario['post_prod_pct'],\n",
        "                        discount_rate=scenario['discount_rate'], forecast_months=scenario['forecast_months']\n",
        "                    )\n",
        "\n",
        "                    # Compute investment metrics\n",
        "                    metrics = compute_investment_metrics(\n",
        "                        result_df, acquisition_cost=scenario['acquisition_cost'],\n",
        "                        discount_rate=scenario['discount_rate'], model_start=scenario['model_start'],\n",
        "                        closing_date=scenario['closing_date']\n",
        "                    )\n",
        "\n",
        "                    # Store results\n",
        "                    all_results.append({\n",
        "                        \"name\": name,\n",
        "                        \"result_df\": result_df,\n",
        "                        \"metrics\": metrics\n",
        "                    })\n",
        "\n",
        "            # --- Display Results ---\n",
        "            st.header(\"Forecast Results\")\n",
        "\n",
        "            if run_all and len(all_results) > 1:\n",
        "                st.subheader(\"Scenario Comparison\")\n",
        "                comparison_data = []\n",
        "                for res in all_results:\n",
        "                    m = res['metrics']\n",
        "                    r = res['result_df']\n",
        "                    comparison_data.append({\n",
        "                        \"Scenario\": res['name'],\n",
        "                        \"NPV ($)\": m['npv'],\n",
        "                        \"Undiscounted CF ($)\": r.attrs['undiscounted_total'],\n",
        "                        \"Discounted CF ($)\": r.attrs['discounted_total'],\n",
        "                        \"IRR (%)\": m['irr_annual'] * 100 if m['irr_annual'] is not None else None,\n",
        "                        \"MOIC (x)\": m['moic'],\n",
        "                        \"Payback (months)\": m['payback_months'],\n",
        "                    })\n",
        "                comp_df = pd.DataFrame(comparison_data).set_index(\"Scenario\")\n",
        "                st.dataframe(comp_df.style.format({\n",
        "                    \"NPV ($)\": \"{:,.0f}\",\n",
        "                    \"Undiscounted CF ($)\": \"{:,.0f}\",\n",
        "                    \"Discounted CF ($)\": \"{:,.0f}\",\n",
        "                    \"IRR (%)\": \"{:.1f}%\",\n",
        "                    \"MOIC (x)\": \"{:.2f}x\",\n",
        "                }))\n",
        "\n",
        "\n",
        "            # Display results for the first (or only) scenario run\n",
        "            first_result = all_results[0]\n",
        "            st.subheader(f\"Summary: {first_result['name']}\")\n",
        "\n",
        "            res_metrics = first_result['metrics']\n",
        "            res_df = first_result['result_df']\n",
        "\n",
        "            # Metrics\n",
        "            c1, c2, c3 = st.columns(3)\n",
        "            c1.metric(\"NPV ($)\", f\"{res_metrics['npv']:,.0f}\")\n",
        "            c2.metric(\"IRR\", f\"{res_metrics['irr_annual']*100:.1f}%\" if res_metrics['irr_annual'] is not None else \"N/A\")\n",
        "            c3.metric(\"MOIC\", f\"{res_metrics['moic']:.2f}x\" if res_metrics['moic'] is not None else \"N/A\")\n",
        "\n",
        "            c1, c2, c3 = st.columns(3)\n",
        "            c1.metric(\"Discounted CF ($)\", f\"{res_df.attrs['discounted_total']:,.0f}\")\n",
        "            payback_label = f\"{res_metrics['payback_months']} months\" if res_metrics['payback_months'] is not None else \"N/A\"\n",
        "            c2.metric(\"Payback Period\", payback_label)\n",
        "            disc_payback_label = f\"{res_metrics['discounted_payback_months']} months\" if res_metrics['discounted_payback_months'] is not None else \"N/A\"\n",
        "            c3.metric(\"Discounted Payback\", disc_payback_label)\n",
        "\n",
        "            # Charts and Tables\n",
        "            st.markdown('**Cash Flow Waterfall**')\n",
        "            waterfall_data = res_metrics['cash_flow_table'].set_index('date')[['cumulative_net_cash', 'cumulative_discounted']]\n",
        "            st.line_chart(waterfall_data, use_container_width=True)\n",
        "\n",
        "            with st.expander('Detailed Cash Flow Table'):\n",
        "                st.dataframe(res_metrics['cash_flow_table'])\n",
        "\n",
        "            csv_data = res_metrics['cash_flow_table'].to_csv(index=False).encode('utf-8')\n",
        "            st.download_button(\n",
        "                label='Download cash flow data as CSV', data=csv_data,\n",
        "                file_name=f'royalty_dcf_{first_result[\"name\"]}.csv', mime='text/csv'\n",
        "            )\n",
        "\n",
        "\n",
        "    # -------------------------------\n",
        "    # Decline Curve Analysis Tab\n",
        "    # -------------------------------\n",
        "    with tab_dca:\n",
        "        st.header('Decline Curve Analysis (DCA)')\n",
        "        st.write(\n",
        "            'Upload historical monthly production data to estimate decline parameters.\\n'\n",
        "            'Supported models: exponential, hyperbolic, and harmonic.  The analysis fits a curve to your data and reports qᵢ, Dᵢ and b (if applicable), along with goodness‑of‑fit metrics.'\n",
        "        )\n",
        "        prod_file = st.file_uploader('Upload production data (CSV)', type=['csv'], key=\"dca_uploader\")\n",
        "        if prod_file is not None:\n",
        "            try:\n",
        "                df = pd.read_csv(prod_file)\n",
        "                # (DCA logic remains the same as original file)\n",
        "                # ...\n",
        "                st.info(\"DCA functionality is available here.\")\n",
        "\n",
        "            except Exception as e:\n",
        "                st.error('An unexpected error occurred while processing your production file. Please check your data and try again.')\n",
        "\n",
        "    # -------------------------------------------------------------------------\n",
        "    # Help & Tutorial Tab\n",
        "    # -------------------------------------------------------------------------\n",
        "    with tab_help:\n",
        "        st.header('Help & Tutorial')\n",
        "        # (Help logic remains the same as original file)\n",
        "        # ...\n",
        "        st.info(\"Help and tutorial information is available here.\")\n",
        "\n",
        "\n",
        "# If executed as a script via Streamlit, render the app\n",
        "if __name__ == '__main__':\n",
        "    if st is not None:\n",
        "        render_app()\n",
        "    else:\n",
        "        print(\n",
        "            'Streamlit is not installed.  Install streamlit and run this script with:\\n'\n",
        "            '    streamlit run foecast.py'\n",
        "        )"
      ],
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Streamlit is not installed.  Install streamlit and run this script with:\n",
            "    streamlit run foecast.py\n"
          ]
        }
      ],
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "SwwEgE3WNmHm",
        "outputId": "590d9bbf-04e5-4dbd-aa6e-4a8402c03142"
      }
    }
  ],
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
